# PRP: Custom CLI Agent Support

**Date:** 2025-12-15
**Feature:** Add option for 1 custom CLI tool with Name, Command, URL, and Enabled fields
**Confidence Score:** 9/10

## Overview

Add the ability to configure one custom CLI coding agent in the LLM Brains settings. When enabled, it appears at the bottom of the toolbar dropdown and launches a terminal with the specified command and title.

## Requirements

1. Add a form section at the bottom of the Settings UI with:
   - **Name** (text field): Display name for the dropdown, e.g., "My Custom Agent"
   - **Command** (text field): CLI command to execute, e.g., "my-agent"
   - **URL** (text field): Documentation/info URL (shown as clickable link)
   - **Enabled** (checkbox): Toggle to show/hide in dropdown

2. If enabled, display the custom agent:
   - Below the built-in agents
   - After a separator
   - With the same hand emoji prefix (ðŸ«´)

3. Clicking the custom agent action launches a terminal with:
   - Tab title: "ðŸ«´ {Name}"
   - Command: {Command} value

## Affected Files

| File | Changes |
|------|---------|
| `AgentSettingsState.kt` | Add fields for custom agent (name, command, url, enabled) |
| `AgentSettingsConfigurable.kt` | Add form fields for custom agent configuration |
| `LlmBrainsActionGroup.kt` | Include custom agent in dropdown when enabled |

## Implementation Details

### 1. AgentSettingsState.kt

Extend the `State` data class to store custom agent configuration:

```kotlin
data class State(
    var inactiveAgentIds: MutableList<String> = mutableListOf(),
    var customAgentEnabled: Boolean = false,
    var customAgentName: String = "",
    var customAgentCommand: String = "",
    var customAgentUrl: String = "",
)
```

Add helper method to get custom agent as `CodingAgent`:

```kotlin
fun getCustomAgent(): CodingAgent? {
    if (!state.customAgentEnabled || state.customAgentName.isBlank() || state.customAgentCommand.isBlank()) {
        return null
    }
    return CodingAgent(
        id = "custom",
        name = state.customAgentName,
        command = state.customAgentCommand,
        versionArgs = "--version",
        installHint = "",
        updateHint = "",
        url = state.customAgentUrl.ifBlank { "https://example.com" },
    )
}
```

### 2. AgentSettingsConfigurable.kt

Add form fields below the existing agent checkboxes:

```kotlin
// Add fields for custom agent
private val customEnabledCheckbox = JBCheckBox("Enable custom agent")
private val customNameField = JBTextField()
private val customCommandField = JBTextField()
private val customUrlField = JBTextField()
```

In `panel` lazy init, after the agent checkboxes:

```kotlin
content.add(Box.createVerticalStrut(16))
content.add(JSeparator())
content.add(Box.createVerticalStrut(8))
content.add(JBLabel("Custom Agent"))
content.add(Box.createVerticalStrut(4))

// Enabled checkbox
content.add(customEnabledCheckbox)
content.add(Box.createVerticalStrut(4))

// Name row
val nameRow = JPanel()
nameRow.layout = BoxLayout(nameRow, BoxLayout.X_AXIS)
nameRow.add(JBLabel("Name: "))
nameRow.add(customNameField)
nameRow.alignmentX = Component.LEFT_ALIGNMENT
content.add(nameRow)
content.add(Box.createVerticalStrut(4))

// Command row
val commandRow = JPanel()
commandRow.layout = BoxLayout(commandRow, BoxLayout.X_AXIS)
commandRow.add(JBLabel("Command: "))
commandRow.add(customCommandField)
commandRow.alignmentX = Component.LEFT_ALIGNMENT
content.add(commandRow)
content.add(Box.createVerticalStrut(4))

// URL row
val urlRow = JPanel()
urlRow.layout = BoxLayout(urlRow, BoxLayout.X_AXIS)
urlRow.add(JBLabel("URL: "))
urlRow.add(customUrlField)
urlRow.alignmentX = Component.LEFT_ALIGNMENT
content.add(urlRow)
```

Update `isModified()`:

```kotlin
override fun isModified(): Boolean {
    val settings = AgentSettingsState.getInstance()
    val builtInModified = CodingAgents.all.any { agent ->
        checkboxes[agent.id]?.isSelected != settings.isAgentActive(agent.id)
    }
    val customModified = customEnabledCheckbox.isSelected != settings.state.customAgentEnabled ||
        customNameField.text != settings.state.customAgentName ||
        customCommandField.text != settings.state.customAgentCommand ||
        customUrlField.text != settings.state.customAgentUrl
    return builtInModified || customModified
}
```

Update `apply()`:

```kotlin
override fun apply() {
    val settings = AgentSettingsState.getInstance()
    CodingAgents.all.forEach { agent ->
        checkboxes[agent.id]?.let { checkBox ->
            settings.setAgentActive(agent.id, checkBox.isSelected)
        }
    }
    settings.state.customAgentEnabled = customEnabledCheckbox.isSelected
    settings.state.customAgentName = customNameField.text
    settings.state.customAgentCommand = customCommandField.text
    settings.state.customAgentUrl = customUrlField.text
}
```

Update `reset()`:

```kotlin
override fun reset() {
    val settings = AgentSettingsState.getInstance()
    CodingAgents.all.forEach { agent ->
        checkboxes[agent.id]?.isSelected = settings.isAgentActive(agent.id)
    }
    customEnabledCheckbox.isSelected = settings.state.customAgentEnabled
    customNameField.text = settings.state.customAgentName
    customCommandField.text = settings.state.customAgentCommand
    customUrlField.text = settings.state.customAgentUrl
}
```

### 3. LlmBrainsActionGroup.kt

In `getChildren()`, after adding active agents but before the settings separator:

```kotlin
// Add custom agent if enabled
val customAgent = settings.getCustomAgent()
if (customAgent != null) {
    if (activeAgents.isNotEmpty()) {
        actions += Separator.getInstance()
    }
    actions += SimpleRunAction(customAgent.dropdownLabel) {
        project?.let { TerminalCommandRunner.run(it, "ðŸ«´ " + customAgent.name, customAgent.command) }
    }
}
```

Modify separator logic - only add separator before settings if there are agents OR custom agent:

```kotlin
if (activeAgents.isNotEmpty() || customAgent != null) {
    actions += Separator.getInstance()
}
```

## Code Patterns Reference

### Existing Settings Pattern (AgentSettingsState.kt:11-39)
```kotlin
@Service(Service.Level.APP)
@State(name = "LlmBrainsAgentSettings", storages = [Storage("LlmBrainsAgentSettings.xml")])
class AgentSettingsState : PersistentStateComponent<AgentSettingsState.State> {
    data class State(
        var inactiveAgentIds: MutableList<String> = mutableListOf(),
    )
    // ...
}
```

### Existing UI Pattern (AgentSettingsConfigurable.kt:22-44)
```kotlin
private val panel: JComponent by lazy {
    JPanel(BorderLayout()).apply {
        val content = JPanel()
        content.layout = BoxLayout(content, BoxLayout.Y_AXIS)
        // ...
        content.add(row)
        add(content, BorderLayout.NORTH)
    }
}
```

### Existing Action Pattern (LlmBrainsActionGroup.kt:18-22)
```kotlin
activeAgents.forEach { agent ->
    actions += SimpleRunAction(agent.dropdownLabel) {
        project?.let { TerminalCommandRunner.run(it, "ðŸ«´ " + agent.name, agent.command) }
    }
}
```

## Required Imports

For `AgentSettingsConfigurable.kt`:
```kotlin
import javax.swing.JSeparator
import com.intellij.ui.components.JBTextField
```

## Implementation Tasks (in order)

1. **AgentSettingsState.kt**: Add custom agent fields to `State` data class
2. **AgentSettingsState.kt**: Add `getCustomAgent()` method
3. **AgentSettingsConfigurable.kt**: Add import for `JSeparator` and `JBTextField`
4. **AgentSettingsConfigurable.kt**: Add private field declarations for custom agent form
5. **AgentSettingsConfigurable.kt**: Add custom agent form section to panel lazy init
6. **AgentSettingsConfigurable.kt**: Update `isModified()` to check custom agent fields
7. **AgentSettingsConfigurable.kt**: Update `apply()` to save custom agent fields
8. **AgentSettingsConfigurable.kt**: Update `reset()` to load custom agent fields
9. **LlmBrainsActionGroup.kt**: Add custom agent to dropdown when enabled
10. **Test manually**: Run `./gradlew runIde` and verify functionality

## Validation Gates

```bash
# Build verification
./gradlew build

# Code formatting
./gradlew ktlintFormat

# Run sandbox IDE for manual testing
./gradlew runIde
```

### Manual Test Cases

1. **Settings UI displays correctly**
   - Open Settings > LLM Brains
   - Verify custom agent section appears below built-in agents
   - Verify all fields (checkbox, name, command, url) are present

2. **Settings persist across IDE restarts**
   - Configure custom agent with test values
   - Restart IDE
   - Verify settings are preserved

3. **Custom agent appears in dropdown when enabled**
   - Enable custom agent with name "Test Agent" and command "echo test"
   - Click toolbar button
   - Verify "ðŸ«´ Test Agent" appears at bottom after separator

4. **Custom agent not shown when disabled**
   - Disable custom agent checkbox
   - Click toolbar button
   - Verify custom agent does not appear

5. **Custom agent launches terminal**
   - Enable custom agent
   - Click custom agent in dropdown
   - Verify terminal opens with title "ðŸ«´ Test Agent"
   - Verify command "echo test" is executed

6. **Empty name/command hides agent**
   - Enable custom agent but leave name or command empty
   - Verify custom agent does not appear in dropdown

## Documentation Reference

- IntelliJ Platform SDK - Persisting State: https://plugins.jetbrains.com/docs/intellij/persisting-state-of-components.html
- IntelliJ Platform SDK - Settings: https://plugins.jetbrains.com/docs/intellij/settings-guide.html
- Swing JTextField: https://docs.oracle.com/javase/tutorial/uiswing/components/textfield.html

## Edge Cases

1. **Empty fields**: Custom agent only shows if both name AND command are non-blank
2. **Whitespace handling**: Trim name/command before use
3. **URL field**: Empty URL is acceptable (use placeholder or hide link)
4. **Special characters**: Command field should support arguments (spaces, quotes)

## Quality Checklist

- [x] All necessary context included
- [x] Validation gates are executable
- [x] References existing patterns
- [x] Clear implementation path
- [x] Error handling documented (edge cases)
- [x] Required imports identified
- [x] Manual test cases defined

## Confidence Score: 9/10

High confidence because:
- Simple extension of existing patterns
- No new dependencies required
- Clear data model changes
- Straightforward UI additions
- Well-documented IntelliJ Platform APIs

Minor uncertainty:
- Layout alignment of text fields may need tweaking for visual polish
